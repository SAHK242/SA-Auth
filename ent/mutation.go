// Code generated by ent, DO NOT EDIT.

package ent

import (
	"auth/ent/auth"
	"auth/ent/department"
	"auth/ent/doctor"
	"auth/ent/employee"
	"auth/ent/nurse"
	"auth/ent/predicate"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuth       = "Auth"
	TypeDepartment = "Department"
	TypeDoctor     = "Doctor"
	TypeEmployee   = "Employee"
	TypeNurse      = "Nurse"
)

// AuthMutation represents an operation that mutates the Auth nodes in the graph.
type AuthMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	email              *string
	username           *string
	password           *string
	state              *int32
	addstate           *int32
	created_date       *time.Time
	last_modified_date *time.Time
	created_by         *uuid.UUID
	last_modified_by   *uuid.UUID
	clearedFields      map[string]struct{}
	employee           *uuid.UUID
	clearedemployee    bool
	done               bool
	oldValue           func(context.Context) (*Auth, error)
	predicates         []predicate.Auth
}

var _ ent.Mutation = (*AuthMutation)(nil)

// authOption allows management of the mutation configuration using functional options.
type authOption func(*AuthMutation)

// newAuthMutation creates new mutation for the Auth entity.
func newAuthMutation(c config, op Op, opts ...authOption) *AuthMutation {
	m := &AuthMutation{
		config:        c,
		op:            op,
		typ:           TypeAuth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthID sets the ID field of the mutation.
func withAuthID(id uuid.UUID) authOption {
	return func(m *AuthMutation) {
		var (
			err   error
			once  sync.Once
			value *Auth
		)
		m.oldValue = func(ctx context.Context) (*Auth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Auth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuth sets the old Auth of the mutation.
func withAuth(node *Auth) authOption {
	return func(m *AuthMutation) {
		m.oldValue = func(context.Context) (*Auth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Auth entities.
func (m *AuthMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Auth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *AuthMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AuthMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AuthMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *AuthMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AuthMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AuthMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AuthMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AuthMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AuthMutation) ResetPassword() {
	m.password = nil
}

// SetState sets the "state" field.
func (m *AuthMutation) SetState(i int32) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *AuthMutation) State() (r int32, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldState(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *AuthMutation) AddState(i int32) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *AuthMutation) AddedState() (r int32, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *AuthMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetCreatedDate sets the "created_date" field.
func (m *AuthMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *AuthMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *AuthMutation) ResetCreatedDate() {
	m.created_date = nil
}

// SetLastModifiedDate sets the "last_modified_date" field.
func (m *AuthMutation) SetLastModifiedDate(t time.Time) {
	m.last_modified_date = &t
}

// LastModifiedDate returns the value of the "last_modified_date" field in the mutation.
func (m *AuthMutation) LastModifiedDate() (r time.Time, exists bool) {
	v := m.last_modified_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedDate returns the old "last_modified_date" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldLastModifiedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifiedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifiedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedDate: %w", err)
	}
	return oldValue.LastModifiedDate, nil
}

// ResetLastModifiedDate resets all changes to the "last_modified_date" field.
func (m *AuthMutation) ResetLastModifiedDate() {
	m.last_modified_date = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AuthMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AuthMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AuthMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[auth.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AuthMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[auth.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AuthMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, auth.FieldCreatedBy)
}

// SetLastModifiedBy sets the "last_modified_by" field.
func (m *AuthMutation) SetLastModifiedBy(u uuid.UUID) {
	m.last_modified_by = &u
}

// LastModifiedBy returns the value of the "last_modified_by" field in the mutation.
func (m *AuthMutation) LastModifiedBy() (r uuid.UUID, exists bool) {
	v := m.last_modified_by
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedBy returns the old "last_modified_by" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldLastModifiedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifiedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifiedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedBy: %w", err)
	}
	return oldValue.LastModifiedBy, nil
}

// ClearLastModifiedBy clears the value of the "last_modified_by" field.
func (m *AuthMutation) ClearLastModifiedBy() {
	m.last_modified_by = nil
	m.clearedFields[auth.FieldLastModifiedBy] = struct{}{}
}

// LastModifiedByCleared returns if the "last_modified_by" field was cleared in this mutation.
func (m *AuthMutation) LastModifiedByCleared() bool {
	_, ok := m.clearedFields[auth.FieldLastModifiedBy]
	return ok
}

// ResetLastModifiedBy resets all changes to the "last_modified_by" field.
func (m *AuthMutation) ResetLastModifiedBy() {
	m.last_modified_by = nil
	delete(m.clearedFields, auth.FieldLastModifiedBy)
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *AuthMutation) SetEmployeeID(id uuid.UUID) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *AuthMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *AuthMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *AuthMutation) EmployeeID() (id uuid.UUID, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *AuthMutation) EmployeeIDs() (ids []uuid.UUID) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *AuthMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the AuthMutation builder.
func (m *AuthMutation) Where(ps ...predicate.Auth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Auth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Auth).
func (m *AuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.email != nil {
		fields = append(fields, auth.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, auth.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, auth.FieldPassword)
	}
	if m.state != nil {
		fields = append(fields, auth.FieldState)
	}
	if m.created_date != nil {
		fields = append(fields, auth.FieldCreatedDate)
	}
	if m.last_modified_date != nil {
		fields = append(fields, auth.FieldLastModifiedDate)
	}
	if m.created_by != nil {
		fields = append(fields, auth.FieldCreatedBy)
	}
	if m.last_modified_by != nil {
		fields = append(fields, auth.FieldLastModifiedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldEmail:
		return m.Email()
	case auth.FieldUsername:
		return m.Username()
	case auth.FieldPassword:
		return m.Password()
	case auth.FieldState:
		return m.State()
	case auth.FieldCreatedDate:
		return m.CreatedDate()
	case auth.FieldLastModifiedDate:
		return m.LastModifiedDate()
	case auth.FieldCreatedBy:
		return m.CreatedBy()
	case auth.FieldLastModifiedBy:
		return m.LastModifiedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auth.FieldEmail:
		return m.OldEmail(ctx)
	case auth.FieldUsername:
		return m.OldUsername(ctx)
	case auth.FieldPassword:
		return m.OldPassword(ctx)
	case auth.FieldState:
		return m.OldState(ctx)
	case auth.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case auth.FieldLastModifiedDate:
		return m.OldLastModifiedDate(ctx)
	case auth.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case auth.FieldLastModifiedBy:
		return m.OldLastModifiedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Auth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auth.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case auth.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case auth.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case auth.FieldState:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case auth.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case auth.FieldLastModifiedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedDate(v)
		return nil
	case auth.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case auth.FieldLastModifiedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthMutation) AddedFields() []string {
	var fields []string
	if m.addstate != nil {
		fields = append(fields, auth.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auth.FieldState:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown Auth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auth.FieldCreatedBy) {
		fields = append(fields, auth.FieldCreatedBy)
	}
	if m.FieldCleared(auth.FieldLastModifiedBy) {
		fields = append(fields, auth.FieldLastModifiedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthMutation) ClearField(name string) error {
	switch name {
	case auth.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case auth.FieldLastModifiedBy:
		m.ClearLastModifiedBy()
		return nil
	}
	return fmt.Errorf("unknown Auth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthMutation) ResetField(name string) error {
	switch name {
	case auth.FieldEmail:
		m.ResetEmail()
		return nil
	case auth.FieldUsername:
		m.ResetUsername()
		return nil
	case auth.FieldPassword:
		m.ResetPassword()
		return nil
	case auth.FieldState:
		m.ResetState()
		return nil
	case auth.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case auth.FieldLastModifiedDate:
		m.ResetLastModifiedDate()
		return nil
	case auth.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case auth.FieldLastModifiedBy:
		m.ResetLastModifiedBy()
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee != nil {
		edges = append(edges, auth.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auth.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedemployee {
		edges = append(edges, auth.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthMutation) EdgeCleared(name string) bool {
	switch name {
	case auth.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthMutation) ClearEdge(name string) error {
	switch name {
	case auth.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Auth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthMutation) ResetEdge(name string) error {
	switch name {
	case auth.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Auth edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	clearedFields    map[string]struct{}
	employees        map[uuid.UUID]struct{}
	removedemployees map[uuid.UUID]struct{}
	clearedemployees bool
	done             bool
	oldValue         func(context.Context) (*Department, error)
	predicates       []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id uuid.UUID) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Department entities.
func (m *DepartmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// AddEmployeeIDs adds the "employees" edge to the Employee entity by ids.
func (m *DepartmentMutation) AddEmployeeIDs(ids ...uuid.UUID) {
	if m.employees == nil {
		m.employees = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// ClearEmployees clears the "employees" edge to the Employee entity.
func (m *DepartmentMutation) ClearEmployees() {
	m.clearedemployees = true
}

// EmployeesCleared reports if the "employees" edge to the Employee entity was cleared.
func (m *DepartmentMutation) EmployeesCleared() bool {
	return m.clearedemployees
}

// RemoveEmployeeIDs removes the "employees" edge to the Employee entity by IDs.
func (m *DepartmentMutation) RemoveEmployeeIDs(ids ...uuid.UUID) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.employees, ids[i])
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed IDs of the "employees" edge to the Employee entity.
func (m *DepartmentMutation) RemovedEmployeesIDs() (ids []uuid.UUID) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the "employees" edge IDs in the mutation.
func (m *DepartmentMutation) EmployeesIDs() (ids []uuid.UUID) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees resets all changes to the "employees" edge.
func (m *DepartmentMutation) ResetEmployees() {
	m.employees = nil
	m.clearedemployees = false
	m.removedemployees = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employees != nil {
		edges = append(edges, department.EdgeEmployees)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployees != nil {
		edges = append(edges, department.EdgeEmployees)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedemployees {
		edges = append(edges, department.EdgeEmployees)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeEmployees:
		return m.clearedemployees
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeEmployees:
		m.ResetEmployees()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DoctorMutation represents an operation that mutates the Doctor nodes in the graph.
type DoctorMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	clearedFields   map[string]struct{}
	employee        *uuid.UUID
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*Doctor, error)
	predicates      []predicate.Doctor
}

var _ ent.Mutation = (*DoctorMutation)(nil)

// doctorOption allows management of the mutation configuration using functional options.
type doctorOption func(*DoctorMutation)

// newDoctorMutation creates new mutation for the Doctor entity.
func newDoctorMutation(c config, op Op, opts ...doctorOption) *DoctorMutation {
	m := &DoctorMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorID sets the ID field of the mutation.
func withDoctorID(id uuid.UUID) doctorOption {
	return func(m *DoctorMutation) {
		var (
			err   error
			once  sync.Once
			value *Doctor
		)
		m.oldValue = func(ctx context.Context) (*Doctor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Doctor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctor sets the old Doctor of the mutation.
func withDoctor(node *Doctor) doctorOption {
	return func(m *DoctorMutation) {
		m.oldValue = func(context.Context) (*Doctor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Doctor entities.
func (m *DoctorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DoctorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DoctorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Doctor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDoctorID sets the "doctor_id" field.
func (m *DoctorMutation) SetDoctorID(u uuid.UUID) {
	m.employee = &u
}

// DoctorID returns the value of the "doctor_id" field in the mutation.
func (m *DoctorMutation) DoctorID() (r uuid.UUID, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorID returns the old "doctor_id" field's value of the Doctor entity.
// If the Doctor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoctorMutation) OldDoctorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoctorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoctorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorID: %w", err)
	}
	return oldValue.DoctorID, nil
}

// ResetDoctorID resets all changes to the "doctor_id" field.
func (m *DoctorMutation) ResetDoctorID() {
	m.employee = nil
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *DoctorMutation) SetEmployeeID(id uuid.UUID) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *DoctorMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[doctor.FieldDoctorID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *DoctorMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *DoctorMutation) EmployeeID() (id uuid.UUID, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) EmployeeIDs() (ids []uuid.UUID) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *DoctorMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the DoctorMutation builder.
func (m *DoctorMutation) Where(ps ...predicate.Doctor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DoctorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DoctorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Doctor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DoctorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DoctorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Doctor).
func (m *DoctorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DoctorMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.employee != nil {
		fields = append(fields, doctor.FieldDoctorID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DoctorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doctor.FieldDoctorID:
		return m.DoctorID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DoctorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doctor.FieldDoctorID:
		return m.OldDoctorID(ctx)
	}
	return nil, fmt.Errorf("unknown Doctor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoctorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doctor.FieldDoctorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorID(v)
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DoctorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DoctorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoctorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DoctorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DoctorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Doctor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DoctorMutation) ResetField(name string) error {
	switch name {
	case doctor.FieldDoctorID:
		m.ResetDoctorID()
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DoctorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee != nil {
		edges = append(edges, doctor.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DoctorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DoctorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DoctorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DoctorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedemployee {
		edges = append(edges, doctor.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DoctorMutation) EdgeCleared(name string) bool {
	switch name {
	case doctor.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DoctorMutation) ClearEdge(name string) error {
	switch name {
	case doctor.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Doctor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DoctorMutation) ResetEdge(name string) error {
	switch name {
	case doctor.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Doctor edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	first_name        *string
	last_name         *string
	gender            *int32
	addgender         *int32
	date_of_birth     *time.Time
	code              *string
	address           *string
	start_date        *time.Time
	end_date          *time.Time
	phone_number      *string
	degree_name       *string
	degree_year       *int32
	adddegree_year    *int32
	employee_type     *int32
	addemployee_type  *int32
	clearedFields     map[string]struct{}
	auth              *uuid.UUID
	clearedauth       bool
	department        *uuid.UUID
	cleareddepartment bool
	doctor            *uuid.UUID
	cleareddoctor     bool
	nurse             *uuid.UUID
	clearednurse      bool
	done              bool
	oldValue          func(context.Context) (*Employee, error)
	predicates        []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id uuid.UUID) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Employee entities.
func (m *EmployeeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "employee_id" field.
func (m *EmployeeMutation) SetEmployeeID(u uuid.UUID) {
	m.auth = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *EmployeeMutation) EmployeeID() (r uuid.UUID, exists bool) {
	v := m.auth
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmployeeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *EmployeeMutation) ResetEmployeeID() {
	m.auth = nil
}

// SetFirstName sets the "first_name" field.
func (m *EmployeeMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *EmployeeMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *EmployeeMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *EmployeeMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *EmployeeMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *EmployeeMutation) ResetLastName() {
	m.last_name = nil
}

// SetGender sets the "gender" field.
func (m *EmployeeMutation) SetGender(i int32) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *EmployeeMutation) Gender() (r int32, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldGender(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *EmployeeMutation) AddGender(i int32) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *EmployeeMutation) AddedGender() (r int32, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *EmployeeMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *EmployeeMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *EmployeeMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDateOfBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *EmployeeMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
}

// SetCode sets the "code" field.
func (m *EmployeeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *EmployeeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *EmployeeMutation) ResetCode() {
	m.code = nil
}

// SetAddress sets the "address" field.
func (m *EmployeeMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *EmployeeMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *EmployeeMutation) ResetAddress() {
	m.address = nil
}

// SetStartDate sets the "start_date" field.
func (m *EmployeeMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *EmployeeMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *EmployeeMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *EmployeeMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *EmployeeMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *EmployeeMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[employee.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *EmployeeMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[employee.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *EmployeeMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, employee.FieldEndDate)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *EmployeeMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *EmployeeMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *EmployeeMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetDegreeName sets the "degree_name" field.
func (m *EmployeeMutation) SetDegreeName(s string) {
	m.degree_name = &s
}

// DegreeName returns the value of the "degree_name" field in the mutation.
func (m *EmployeeMutation) DegreeName() (r string, exists bool) {
	v := m.degree_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDegreeName returns the old "degree_name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDegreeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDegreeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDegreeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegreeName: %w", err)
	}
	return oldValue.DegreeName, nil
}

// ResetDegreeName resets all changes to the "degree_name" field.
func (m *EmployeeMutation) ResetDegreeName() {
	m.degree_name = nil
}

// SetDegreeYear sets the "degree_year" field.
func (m *EmployeeMutation) SetDegreeYear(i int32) {
	m.degree_year = &i
	m.adddegree_year = nil
}

// DegreeYear returns the value of the "degree_year" field in the mutation.
func (m *EmployeeMutation) DegreeYear() (r int32, exists bool) {
	v := m.degree_year
	if v == nil {
		return
	}
	return *v, true
}

// OldDegreeYear returns the old "degree_year" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDegreeYear(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDegreeYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDegreeYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegreeYear: %w", err)
	}
	return oldValue.DegreeYear, nil
}

// AddDegreeYear adds i to the "degree_year" field.
func (m *EmployeeMutation) AddDegreeYear(i int32) {
	if m.adddegree_year != nil {
		*m.adddegree_year += i
	} else {
		m.adddegree_year = &i
	}
}

// AddedDegreeYear returns the value that was added to the "degree_year" field in this mutation.
func (m *EmployeeMutation) AddedDegreeYear() (r int32, exists bool) {
	v := m.adddegree_year
	if v == nil {
		return
	}
	return *v, true
}

// ResetDegreeYear resets all changes to the "degree_year" field.
func (m *EmployeeMutation) ResetDegreeYear() {
	m.degree_year = nil
	m.adddegree_year = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *EmployeeMutation) SetDepartmentID(u uuid.UUID) {
	m.department = &u
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *EmployeeMutation) DepartmentID() (r uuid.UUID, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDepartmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *EmployeeMutation) ResetDepartmentID() {
	m.department = nil
}

// SetEmployeeType sets the "employee_type" field.
func (m *EmployeeMutation) SetEmployeeType(i int32) {
	m.employee_type = &i
	m.addemployee_type = nil
}

// EmployeeType returns the value of the "employee_type" field in the mutation.
func (m *EmployeeMutation) EmployeeType() (r int32, exists bool) {
	v := m.employee_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeType returns the old "employee_type" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEmployeeType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeType: %w", err)
	}
	return oldValue.EmployeeType, nil
}

// AddEmployeeType adds i to the "employee_type" field.
func (m *EmployeeMutation) AddEmployeeType(i int32) {
	if m.addemployee_type != nil {
		*m.addemployee_type += i
	} else {
		m.addemployee_type = &i
	}
}

// AddedEmployeeType returns the value that was added to the "employee_type" field in this mutation.
func (m *EmployeeMutation) AddedEmployeeType() (r int32, exists bool) {
	v := m.addemployee_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployeeType resets all changes to the "employee_type" field.
func (m *EmployeeMutation) ResetEmployeeType() {
	m.employee_type = nil
	m.addemployee_type = nil
}

// SetAuthID sets the "auth" edge to the Auth entity by id.
func (m *EmployeeMutation) SetAuthID(id uuid.UUID) {
	m.auth = &id
}

// ClearAuth clears the "auth" edge to the Auth entity.
func (m *EmployeeMutation) ClearAuth() {
	m.clearedauth = true
	m.clearedFields[employee.FieldEmployeeID] = struct{}{}
}

// AuthCleared reports if the "auth" edge to the Auth entity was cleared.
func (m *EmployeeMutation) AuthCleared() bool {
	return m.clearedauth
}

// AuthID returns the "auth" edge ID in the mutation.
func (m *EmployeeMutation) AuthID() (id uuid.UUID, exists bool) {
	if m.auth != nil {
		return *m.auth, true
	}
	return
}

// AuthIDs returns the "auth" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) AuthIDs() (ids []uuid.UUID) {
	if id := m.auth; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuth resets all changes to the "auth" edge.
func (m *EmployeeMutation) ResetAuth() {
	m.auth = nil
	m.clearedauth = false
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *EmployeeMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[employee.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *EmployeeMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) DepartmentIDs() (ids []uuid.UUID) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *EmployeeMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetDoctorID sets the "doctor" edge to the Doctor entity by id.
func (m *EmployeeMutation) SetDoctorID(id uuid.UUID) {
	m.doctor = &id
}

// ClearDoctor clears the "doctor" edge to the Doctor entity.
func (m *EmployeeMutation) ClearDoctor() {
	m.cleareddoctor = true
}

// DoctorCleared reports if the "doctor" edge to the Doctor entity was cleared.
func (m *EmployeeMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorID returns the "doctor" edge ID in the mutation.
func (m *EmployeeMutation) DoctorID() (id uuid.UUID, exists bool) {
	if m.doctor != nil {
		return *m.doctor, true
	}
	return
}

// DoctorIDs returns the "doctor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) DoctorIDs() (ids []uuid.UUID) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor resets all changes to the "doctor" edge.
func (m *EmployeeMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// SetNurseID sets the "nurse" edge to the Nurse entity by id.
func (m *EmployeeMutation) SetNurseID(id uuid.UUID) {
	m.nurse = &id
}

// ClearNurse clears the "nurse" edge to the Nurse entity.
func (m *EmployeeMutation) ClearNurse() {
	m.clearednurse = true
}

// NurseCleared reports if the "nurse" edge to the Nurse entity was cleared.
func (m *EmployeeMutation) NurseCleared() bool {
	return m.clearednurse
}

// NurseID returns the "nurse" edge ID in the mutation.
func (m *EmployeeMutation) NurseID() (id uuid.UUID, exists bool) {
	if m.nurse != nil {
		return *m.nurse, true
	}
	return
}

// NurseIDs returns the "nurse" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NurseID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) NurseIDs() (ids []uuid.UUID) {
	if id := m.nurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNurse resets all changes to the "nurse" edge.
func (m *EmployeeMutation) ResetNurse() {
	m.nurse = nil
	m.clearednurse = false
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.auth != nil {
		fields = append(fields, employee.FieldEmployeeID)
	}
	if m.first_name != nil {
		fields = append(fields, employee.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, employee.FieldLastName)
	}
	if m.gender != nil {
		fields = append(fields, employee.FieldGender)
	}
	if m.date_of_birth != nil {
		fields = append(fields, employee.FieldDateOfBirth)
	}
	if m.code != nil {
		fields = append(fields, employee.FieldCode)
	}
	if m.address != nil {
		fields = append(fields, employee.FieldAddress)
	}
	if m.start_date != nil {
		fields = append(fields, employee.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, employee.FieldEndDate)
	}
	if m.phone_number != nil {
		fields = append(fields, employee.FieldPhoneNumber)
	}
	if m.degree_name != nil {
		fields = append(fields, employee.FieldDegreeName)
	}
	if m.degree_year != nil {
		fields = append(fields, employee.FieldDegreeYear)
	}
	if m.department != nil {
		fields = append(fields, employee.FieldDepartmentID)
	}
	if m.employee_type != nil {
		fields = append(fields, employee.FieldEmployeeType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldEmployeeID:
		return m.EmployeeID()
	case employee.FieldFirstName:
		return m.FirstName()
	case employee.FieldLastName:
		return m.LastName()
	case employee.FieldGender:
		return m.Gender()
	case employee.FieldDateOfBirth:
		return m.DateOfBirth()
	case employee.FieldCode:
		return m.Code()
	case employee.FieldAddress:
		return m.Address()
	case employee.FieldStartDate:
		return m.StartDate()
	case employee.FieldEndDate:
		return m.EndDate()
	case employee.FieldPhoneNumber:
		return m.PhoneNumber()
	case employee.FieldDegreeName:
		return m.DegreeName()
	case employee.FieldDegreeYear:
		return m.DegreeYear()
	case employee.FieldDepartmentID:
		return m.DepartmentID()
	case employee.FieldEmployeeType:
		return m.EmployeeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case employee.FieldFirstName:
		return m.OldFirstName(ctx)
	case employee.FieldLastName:
		return m.OldLastName(ctx)
	case employee.FieldGender:
		return m.OldGender(ctx)
	case employee.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case employee.FieldCode:
		return m.OldCode(ctx)
	case employee.FieldAddress:
		return m.OldAddress(ctx)
	case employee.FieldStartDate:
		return m.OldStartDate(ctx)
	case employee.FieldEndDate:
		return m.OldEndDate(ctx)
	case employee.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case employee.FieldDegreeName:
		return m.OldDegreeName(ctx)
	case employee.FieldDegreeYear:
		return m.OldDegreeYear(ctx)
	case employee.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case employee.FieldEmployeeType:
		return m.OldEmployeeType(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldEmployeeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case employee.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case employee.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case employee.FieldGender:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case employee.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case employee.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case employee.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case employee.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case employee.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case employee.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case employee.FieldDegreeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegreeName(v)
		return nil
	case employee.FieldDegreeYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegreeYear(v)
		return nil
	case employee.FieldDepartmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case employee.FieldEmployeeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeType(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, employee.FieldGender)
	}
	if m.adddegree_year != nil {
		fields = append(fields, employee.FieldDegreeYear)
	}
	if m.addemployee_type != nil {
		fields = append(fields, employee.FieldEmployeeType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldGender:
		return m.AddedGender()
	case employee.FieldDegreeYear:
		return m.AddedDegreeYear()
	case employee.FieldEmployeeType:
		return m.AddedEmployeeType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case employee.FieldGender:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case employee.FieldDegreeYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDegreeYear(v)
		return nil
	case employee.FieldEmployeeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeeType(v)
		return nil
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldEndDate) {
		fields = append(fields, employee.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case employee.FieldFirstName:
		m.ResetFirstName()
		return nil
	case employee.FieldLastName:
		m.ResetLastName()
		return nil
	case employee.FieldGender:
		m.ResetGender()
		return nil
	case employee.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case employee.FieldCode:
		m.ResetCode()
		return nil
	case employee.FieldAddress:
		m.ResetAddress()
		return nil
	case employee.FieldStartDate:
		m.ResetStartDate()
		return nil
	case employee.FieldEndDate:
		m.ResetEndDate()
		return nil
	case employee.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case employee.FieldDegreeName:
		m.ResetDegreeName()
		return nil
	case employee.FieldDegreeYear:
		m.ResetDegreeYear()
		return nil
	case employee.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case employee.FieldEmployeeType:
		m.ResetEmployeeType()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.auth != nil {
		edges = append(edges, employee.EdgeAuth)
	}
	if m.department != nil {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.doctor != nil {
		edges = append(edges, employee.EdgeDoctor)
	}
	if m.nurse != nil {
		edges = append(edges, employee.EdgeNurse)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeAuth:
		if id := m.auth; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeNurse:
		if id := m.nurse; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedauth {
		edges = append(edges, employee.EdgeAuth)
	}
	if m.cleareddepartment {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.cleareddoctor {
		edges = append(edges, employee.EdgeDoctor)
	}
	if m.clearednurse {
		edges = append(edges, employee.EdgeNurse)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeAuth:
		return m.clearedauth
	case employee.EdgeDepartment:
		return m.cleareddepartment
	case employee.EdgeDoctor:
		return m.cleareddoctor
	case employee.EdgeNurse:
		return m.clearednurse
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeAuth:
		m.ClearAuth()
		return nil
	case employee.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case employee.EdgeDoctor:
		m.ClearDoctor()
		return nil
	case employee.EdgeNurse:
		m.ClearNurse()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeAuth:
		m.ResetAuth()
		return nil
	case employee.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case employee.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case employee.EdgeNurse:
		m.ResetNurse()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// NurseMutation represents an operation that mutates the Nurse nodes in the graph.
type NurseMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	clearedFields   map[string]struct{}
	employee        *uuid.UUID
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*Nurse, error)
	predicates      []predicate.Nurse
}

var _ ent.Mutation = (*NurseMutation)(nil)

// nurseOption allows management of the mutation configuration using functional options.
type nurseOption func(*NurseMutation)

// newNurseMutation creates new mutation for the Nurse entity.
func newNurseMutation(c config, op Op, opts ...nurseOption) *NurseMutation {
	m := &NurseMutation{
		config:        c,
		op:            op,
		typ:           TypeNurse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNurseID sets the ID field of the mutation.
func withNurseID(id uuid.UUID) nurseOption {
	return func(m *NurseMutation) {
		var (
			err   error
			once  sync.Once
			value *Nurse
		)
		m.oldValue = func(ctx context.Context) (*Nurse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nurse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNurse sets the old Nurse of the mutation.
func withNurse(node *Nurse) nurseOption {
	return func(m *NurseMutation) {
		m.oldValue = func(context.Context) (*Nurse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NurseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NurseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Nurse entities.
func (m *NurseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NurseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NurseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Nurse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNurseID sets the "nurse_id" field.
func (m *NurseMutation) SetNurseID(u uuid.UUID) {
	m.employee = &u
}

// NurseID returns the value of the "nurse_id" field in the mutation.
func (m *NurseMutation) NurseID() (r uuid.UUID, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseID returns the old "nurse_id" field's value of the Nurse entity.
// If the Nurse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NurseMutation) OldNurseID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNurseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNurseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseID: %w", err)
	}
	return oldValue.NurseID, nil
}

// ResetNurseID resets all changes to the "nurse_id" field.
func (m *NurseMutation) ResetNurseID() {
	m.employee = nil
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *NurseMutation) SetEmployeeID(id uuid.UUID) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *NurseMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[nurse.FieldNurseID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *NurseMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *NurseMutation) EmployeeID() (id uuid.UUID, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *NurseMutation) EmployeeIDs() (ids []uuid.UUID) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *NurseMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the NurseMutation builder.
func (m *NurseMutation) Where(ps ...predicate.Nurse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NurseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NurseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Nurse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NurseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NurseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Nurse).
func (m *NurseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NurseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.employee != nil {
		fields = append(fields, nurse.FieldNurseID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NurseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nurse.FieldNurseID:
		return m.NurseID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NurseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nurse.FieldNurseID:
		return m.OldNurseID(ctx)
	}
	return nil, fmt.Errorf("unknown Nurse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NurseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nurse.FieldNurseID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseID(v)
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NurseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NurseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NurseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NurseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NurseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NurseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Nurse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NurseMutation) ResetField(name string) error {
	switch name {
	case nurse.FieldNurseID:
		m.ResetNurseID()
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NurseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee != nil {
		edges = append(edges, nurse.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NurseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NurseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NurseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NurseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedemployee {
		edges = append(edges, nurse.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NurseMutation) EdgeCleared(name string) bool {
	switch name {
	case nurse.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NurseMutation) ClearEdge(name string) error {
	switch name {
	case nurse.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Nurse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NurseMutation) ResetEdge(name string) error {
	switch name {
	case nurse.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Nurse edge %s", name)
}
